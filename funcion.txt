
/**
 * @brief Funcion que entrega un vector de string el cual
 * contiene las "direcciones de memoria" que se usaran, tomadas
 * del las direcciones disponibles
 * 
 * @return std::vector<string> 
 */
void Motor::set_aval_address(){

    /**
     * @brief vector con las direcciones de memoria
     * disponibles
     */
    std::vector<string> disponibles= {"D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D10"};
    /**
     * @brief vector que contendra las posiciones de memoria
     * a uar las cuales se selecconaran aleatoriamente a partir del
     * conjunto de memorias disponibles
     */
    std::vector<string> usadas;

    /**
     * @brief varible auxiliar para el ciclo
     * toma el mismo valor del total de las posiciones
     * de memoria a usar
     *
     */
    int limite_memoria = CANT_DIR;

    /**
     * @brief variable receptora
     * para uso en el ciclo
     * 
     */
    string receptor = "";

    // ciclo

    /**
     * @brief Ciclo que configura el contenido
     * final con las direcciones de memoria a usar
     * 
     */
    for (int i = 0; i < limite_memoria; i++)
    {
        int sel_dir = number_aleat(disponibles.size());

        receptor = disponibles.at(sel_dir);

        if (esta_dentro(receptor,usadas))
        {
            usadas.clear();
            cout<<"...borrada..usadas.."<<endl;
            set_aval_address();
        }
        else
        {
            usadas.push_back(receptor);
        }

    }


    /**
     * @brief ciclo para verificacion del proceso
     * 
     * @param usadas 
     */
    for (string mem : usadas)
    {
        cout<<"Las que QUEDAN y se van a usar " + mem <<endl;
    }

    the_aval_address = usadas;

}